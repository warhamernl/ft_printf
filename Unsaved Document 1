https://www.dummies.com/programming/c/how-to-use-conversion-characters-in-the-c-languages-printf-function/

%% 	The percent character, %
%c 	Single character (char) value
%d 	Integer (int, short int, long int)
value
%e 	Floating-point (float or double) value in scientific notation with a
little E
%E 	Floating-point (float or double) value in scientific notation with a big
E
%f 	Floating-point (float or double) value in decimal notation
%g 	Either %f or %e is used, depending on which is shorter
%G 	Either %F or %E is used, depending on which is shorter
%i 	Integer (int, short int, long int)
value
%o 	Unsigned octal value (no leading 0)
%p 	Memory location or address in hexadecimal (pointer)
%s 	String constant or variable (char
*)
%u 	Unsigned integer (unsigned int, unsigned short int, unsigned
long int) value
%x 	Unsigned hexadecimal value, lowercase a–f, no leading 0
or x
%X 	Unsigned hexadecimal value, uppercase A–F, no leading 0
or X


       hh     A following integer conversion corresponds to a signed char or
              unsigned char argument, or a following n conversion corre‐
              sponds to a pointer to a signed char argument.

       h      A following integer conversion corresponds to a short int or
              unsigned short int argument, or a following n conversion cor‐
              responds to a pointer to a short int argument.

       l      (ell) A following integer conversion corresponds to a long int
              or unsigned long int argument, or a following n conversion
              corresponds to a pointer to a long int argument, or a follow‐
              ing c conversion corresponds to a wint_t argument, or a fol‐
              lowing s conversion corresponds to a pointer to wchar_t argu‐
              ment.

       ll     (ell-ell).  A following integer conversion corresponds to a
              long long int or unsigned long long int argument, or a follow‐
              ing n conversion corresponds to a pointer to a long long int
              argument.


       L      A following a, A, e, E, f, F, g, or G conversion corresponds
              to a long double argument.  (C99 allows %LF, but SUSv2 does
              not.)



[0;31m	Red
[1;31m	Bold Red
[0;32m	Green
[1;32m	Bold Green
[0;33m	Yellow
[01;33m	Bold Yellow
[0;34m	Blue
[1;34m	Bold Blue
[0;35m	Magenta
[1;35m	Bold Magenta
[0;36m	Cyan
[1;36m	Bold Cyan
[0m	Reset

%% is een %

 Flag characters
       The character % is followed by zero or more of the following flags:

       #      The value should be converted to an "alternate form".  For o
              conversions, the first character of the output string is made
              zero (by prefixing a 0 if it was not zero already).  For x and
              X conversions, a nonzero result has the string "0x" (or "0X"
              for X conversions) prepended to it.  For a, A, e, E, f, F, g,
              and G conversions, the result will always contain a decimal
              point, even if no digits follow it (normally, a decimal point
              appears in the results of those conversions only if a digit
              follows).  For g and G conversions, trailing zeros are not
              removed from the result as they would otherwise be.  For other
              conversions, the result is undefined.

       0      The value should be zero padded.  For d, i, o, u, x, X, a, A,
              e, E, f, F, g, and G conversions, the converted value is
              padded on the left with zeros rather than blanks.  If the 0
              and - flags both appear, the 0 flag is ignored.  If a preci‐
              sion is given with a numeric conversion (d, i, o, u, x, and
              X), the 0 flag is ignored.  For other conversions, the behav‐
              ior is undefined.

       -      The converted value is to be left adjusted on the field bound‐
              ary.  (The default is right justification.)  The converted
              value is padded on the right with blanks, rather than on the
              left with blanks or zeros.  A - overrides a 0 if both are
              given.

       ' '    (a space) A blank should be left before a positive number (or
              empty string) produced by a signed conversion.

       +      A sign (+ or -) should always be placed before a number pro‐
              duced by a signed conversion.  By default, a sign is used only
              for negative numbers.  A + overrides a space if both are used.

   Field width
       An optional decimal digit string (with nonzero first digit) specify‐
       ing a minimum field width.  If the converted value has fewer charac‐
       ters than the field width, it will be padded with spaces on the left
       (or right, if the left-adjustment flag has been given).  Instead of a
       decimal digit string one may write "*" or "*m$" (for some decimal
       integer m) to specify that the field width is given in the next argu‐
       ment, or in the m-th argument, respectively, which must be of type
       int.  A negative field width is taken as a '-' flag followed by a
       positive field width.  In no case does a nonexistent or small field
       width cause truncation of a field; if the result of a conversion is
       wider than the field width, the field is expanded to contain the con‐
       version result.

   Precision
       An optional precision, in the form of a period ('.')  followed by an
       optional decimal digit string.  Instead of a decimal digit string one
       may write "*" or "*m$" (for some decimal integer m) to specify that
       the precision is given in the next argument, or in the m-th argument,
       respectively, which must be of type int.  If the precision is given
       as just '.', the precision is taken to be zero.  A negative precision
       is taken as if the precision were omitted.  This gives the minimum
       number of digits to appear for d, i, o, u, x, and X conversions, the
       number of digits to appear after the radix character for a, A, e, E,
       f, and F conversions, the maximum number of significant digits for g
       and G conversions, or the maximum number of characters to be printed
       from a string for s and S conversions.



       g, G   The double argument is converted in style f or e (or F or E
              for G conversions).  The precision specifies the number of
              significant digits.  If the precision is missing, 6 digits are
              given; if the precision is zero, it is treated as 1.  Style e
              is used if the exponent from its conversion is less than -4 or
              greater than or equal to the precision.  Trailing zeros are
              removed from the fractional part of the result; a decimal
              point appears only if it is followed by at least one digit.


      e, E   The double argument is rounded and converted in the style
              [-]d.ddde±dd where there is one digit before the decimal-point
              character and the number of digits after it is equal to the
              precision; if the precision is missing, it is taken as 6; if
              the precision is zero, no decimal-point character appears.  An
              E conversion uses the letter E (rather than e) to introduce
              the exponent.  The exponent always contains at le



emiflakeToday at 9:25 PM
There is IIRC
look at the C standard
Anyway, here's a summary
- * -> %*d, will take * as the width from the arguments
e.g.
printf("%*.*f", 10/*width*/, 20/*precision*/, 42.42);
- $ is positional argument, it will take the value from nth position in arguments
e.g.
printf("%2$d, %1$d", 10, 20); // Will print `20, 10`
Something like that
And idk about the '
it has something to do with formatting large numbers
but I don't know the specifics
 
BaksteenToday at 9:29 PM
so the first one is actually makiing the precision same as the width
atleast it takes the same argument
 
emiflakeToday at 9:29 PM
no no
it just moves
the input from the format string
to the arguments
printf("%5d", 42);
// to
printf("%*d", 5, 42);
those are equivalent
 
BaksteenToday at 9:30 PM
ooooooh
weird ass shit
i get it
it tho
 
emiflakeToday at 9:30 PM
it's nice
but
$ is hard to implement
 
BaksteenToday at 9:31 PM
im just making a plan right now
did you do it ?
 
emiflakeToday at 9:32 PM
nope
only *
 
BaksteenToday at 9:32 PM
btw what does the second one do?
swithing arguments?
 
emiflakeToday at 9:32 PM
well
it allows you to specify which argument you want
in that case
I specified that it wanted the second one and then the third

